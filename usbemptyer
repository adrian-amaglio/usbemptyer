#!/bin/bash
declare -A usage
declare -A varia

default_host="http://local.dahus:49291"

version=1.0
summary="$0 [options]"

usage[d]="The device that will be copied"
varia[d]=device
device=""

usage[i]="Install and exit"
varia[i]=install
install=false

usage[e]="Regular expression. Files that match it recursiverly will be copied. Casse INsensitive"
varia[e]=regex
regex='*.wav'

usage[c]="Remove ALL device content after copy. Without confirmation"
varia[c]=remove
remove=false

# TODO make it a table, and save to several places
usage[l]="Location where file will be sent. Support local filesystem"
varia[l]=location
location="/data/bruts"

usage[n]="Notify when the copy is complete. Send an http get request."
varia[n]=notify_end
notify_end="$default_host/end"

usage[f]="Each file will notify this URI when begining to copy"
varia[f]=notify_file
notify_file="$default_host/file"

usage[b]="Notified URL when usb is pluged"
varia[b]=notify_start
notify_start="$default_host/start"

usage[p]="Prompt for the name"
varia[p]=prompt
prompt=""

usage[u]="Udev system file"
varia[u]=udev_file
udev_file="/etc/udev/rules.d/usb-emptyer.rules"

usage[s]="Date format string for temporar name"
varia[s]=date_format
date_format="+%Y.%m.%d-%H.%M.%S"

usage[x]="Url to notify on failure"
varia[x]=notify_failure
notify_failure="$default_host/fail"

. driglibash-args
root_or_die

if [ "$install" == true ] ; then
  current_dir="$(where "$0")"
  # TODO escape the executable location
  cat > "$udev_file" <<-EOF
    SUBSYSTEM=="block", KERNEL=="*", RUN+="$current_dir/usbemptyer -d %k -x '$notify_failure' -l '$location' -f '$notify_file' -n '$notify_end' -b '$notify_start' -s '$date_format' -e '$regex'"
EOF
  udevadm control --reload-rules
  exit 0
fi

# Test for mandatory arguments
if [ -z "$location" ] ; then die "No destination supplied" ; fi
if [ "$ACTION" != "add" ] ; then die "Action '$ACTION' not supported" ; fi # TODO filter udev

# Construct needed strings
tmpname="$(date $date_format)"

run mkdir -p "$location/$tmpname"
run mount "/dev/$device" "/mnt"
clean "umount /mnt"

if [ -n "$notify_start" ] ; then curl "$notify_start/$tmpname" ; fi

for line in $(find /mnt -iname "$regex") ; do
  short_name="$(basename $line)"
  if [ -n "$notify_file" ] ; then curl "$notify_file/$tmpname/$short_name" ; fi
  run cp -r "$line" "$location/$tmpname/$short_name"
  # curl \
  #   --header "Content-Type:application/octet-stream" \
  #   --trace-ascii debugdump.txt \
  #   -X POST \
  #   --data-binary @{} "$location/$tmpname" \
done

# Terminating
#if [ "$remove" == true ] ; then run rm -rf "/mnt/*" ; fi
new_name="no"
while [ "$new_name" == "no" ] ; do
  new_name=$(curl "$notify_end/$tmpname")
  sleep 3
done
mv "$location/$tmpname" "$location/$tmpname--$new_name"

run find /mnt -iname "$regex" -exec rm "{}" ;
clean
